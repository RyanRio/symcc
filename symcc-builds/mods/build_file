#!/usr/bin/env python3

import subprocess
import sys
import yaml
import os
import shutil
import argparse

_environ = os.environ.copy()

# parse args
parser = argparse.ArgumentParser()
parser.add_argument("--f", nargs=1, dest="file", help="run with given input'")
parser.add_argument("-c", dest="clean", action='store_true', help="clean directory structure")
parser.add_argument("--arch", dest="arch", choices=["32", "64"], default="BOTH", help="optionally build just 32 bit or 64 bit")
parser.add_argument("--runtime", dest="runtime", choices=["z3", "qsym"], default="qsym", help="build with the z3 runtime backend or the qsym runtime backend")

args = parser.parse_args()

arch = args.arch
runtime = args.runtime

# set up directories
top_dir = os.getcwd()
programs32 = os.path.join(top_dir, "programs32")
programs64 = os.path.join(top_dir, "programs64")
programs32_build = os.path.join(top_dir, "programs32_build")
programs64_build = os.path.join(top_dir, "programs64_build")

os.environ["RYANRIO_COMPILE_LOG_FILE"] = f"compile_log"

if args.clean:
    shutil.rmtree(programs32_build)
    os.mkdir(programs32_build)
    shutil.rmtree(programs64_build)
    os.mkdir(programs64_build)
    exit(0)

# set up builds
supported_programs = ["simple.c"]

# how to run the executable
executable_mapping = {
    "simple.c": "simple"
}

# get the runtime directory given a certain architecture
def getRuntimeDir(arch):
    parent = os.path.dirname(top_dir)
    return os.path.join(parent, f"{runtime}-build-{arch}")

def build_input(executable):
    if args.file:
        return ['echo', args.file[0], '|', './' + executable]
    else:
        return ['echo', "aaaa", '|', './' + executable]

def build(runtime):
    #symcc build
    runtime_dir = getRuntimeDir(runtime)
    CC = os.path.join(runtime_dir, "symcc")
    CXX = os.path.join(runtime_dir, "sym++")
    CFLAGS = "-m32 -w" if runtime == "32" else ""
    os.environ["CC"] = CC
    os.environ["CXX"] = CXX
    os.environ["CCFLAGS"] = CFLAGS
    os.environ["CFLAGS"] = CFLAGS
    os.environ["SYMCC_NO_SYMBOLIC_INPUT"] = "1"

    print(CC)

    # programs
    for program in supported_programs:
        BUILD_OPTIONS = [CC, f"custom_programs/{program}", "-o", executable_mapping[program]]
        result = subprocess.run(BUILD_OPTIONS, env=os.environ)

        if result.returncode == 0:
            cmd = build_input(executable_mapping[program])
            print(cmd)
            os.environ["SYMCC_NO_SYMBOLIC_INPUT"] = "0"
            subprocess.run(' '.join(cmd), shell=True, env=os.environ)
        else:
            exit(result.returncode)

if arch == "BOTH":
    build("32")
    build("64")
else:
    build(arch)

os.environ.clear()
os.environ.update(_environ)
